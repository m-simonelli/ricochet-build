#!/bin/bash
set -x
[% c("var/set_default_env") -%]
[% pc(c('var/compiler'), 'var/setup', { compiler_tarfile => c('input_files_by_name/' _ c('var/compiler')) }) %]
distdir=/var/tmp/dist/[% project %]
mkdir -p /var/tmp/build

tar -C /var/tmp/dist -xf [% c('input_files_by_name/openssl') %]
tar -C /var/tmp/dist -xf [% c('input_files_by_name/protoc') %]
export PATH=/var/tmp/dist/protoc/bin:$PATH
tar -C /var/tmp/dist -xf [% c('input_files_by_name/protobuf') %]
tar -C /var/tmp/dist -xf [% c('input_files_by_name/qt') %]
export PATH=/var/tmp/dist/qt/bin:$PATH
tar -C /var/tmp/dist -xf [% c('input_files_by_name/cmake') %]
export PATH=/var/tmp/dist/cmake/bin:$PATH

tar -C /var/tmp/build -xf [% project %]-[% c('version') %].tar.gz
cd /var/tmp/build/[% project %]-[% c('version') %]/

mkdir -p /var/tmp/dist/pluggables
tar -C /var/tmp/dist/pluggables -xf $rootdir/pluggable-transports.tar.gz

# Generate the pluggables header
# 1. create a std::map of bridgeType.N -> bridgestring where N is an integer >0
# TODO: since the map is rather small, this can be optimized into a "constexpr"
# map (see Jason Turner's C++ weekly ep 233) - although for how much this map
# is used, it might not be worth the added effort.
PT_HEADER_PATH=/var/tmp/build/[% project %]-[% c('version') %]/src/libtego_ui/pluggables.hpp
touch $PT_HEADER_PATH
echo "#pragma once" > $PT_HEADER_PATH
echo "const std::map<std::string, std::string> defaultBridges = {" >> $PT_HEADER_PATH
function bridges_conf {
  local pt="$1"
  local i=1
  while read -r line
  do
    echo "    {\"$pt.$i\", \"$line\"}," >> "$PT_HEADER_PATH"
    i=$((i + 1))
  done < "/var/tmp/dist/pluggables/bridges_list.$pt.txt"
}
bridges_conf obfs4
bridges_conf meek-azure
bridges_conf snowflake

# 2. remove the last ',' character so we can close this map
sed -i '$ s/,$//' $PT_HEADER_PATH
echo "};" >> $PT_HEADER_PATH

# 3. set obfs4 as the recommended bridge type
echo "constexpr std::string_view recommendedBridgeType = \"obfs4\";" >> $PT_HEADER_PATH

# Generate the torrc header
# Since RicochetRefresh generates a default torrc at runtime, we put the contents
# of the PT torrc config in a header, with those contents being included when
# RicochetRefresh generates the default torrc
#TODO: At some point it'd be nice to have some way of automatically generating
# these torrc appendices based on the ones in tor-browser-build
[% IF c("var/osx") -%]
TORRC_DEFAULT_APPENDIX=$rootdir/resources/darwin/default_torrc-appendix
[% END -%]
[% IF c("var/linux") -%]
TORRC_DEFAULT_APPENDIX=$rootdir/resources/linux/default_torrc-appendix
[% END -%]
[% IF c("var/windows") -%]
TORRC_DEFAULT_APPENDIX=$rootdir/resources/windows/default_torrc-appendix
[% END -%]

TORRC_HEADER_PATH=/var/tmp/build/[% project %]-[% c('version') %]/src/libtego/source/torrc.hpp
echo "#pragma once" > "$TORRC_HEADER_PATH"
echo "const std::string defaultTorrcPluggableConfig =" >> "$TORRC_HEADER_PATH"
while read -r line
do
    echo "\"$line\\n\"" >> "$TORRC_HEADER_PATH"
done < "$TORRC_DEFAULT_APPENDIX"
echo ";" >> $TORRC_HEADER_PATH

# clang needs to be reminded where its c++ includes are
[% IF c("var/osx") -%]
cppincludes=/var/tmp/dist/macosx-toolchain/clang/include/c++/v1
export CPLUS_INCLUDE_PATH=$cppincludes:$CPLUS_INCLUDE_PATH
export PKG_CONFIG_LIBDIR=$sysrootdir/lib/pkgconfig
[% END -%]

# mingw doesn't define CC or CXX, and cmake needs those set to use mingw 
[% IF c("var/windows-i686") -%]
export CC=/var/tmp/dist/mingw-w64/bin/i686-w64-mingw32-gcc
export CXX=/var/tmp/dist/mingw-w64/bin/i686-w64-mingw32-g++
[% END -%]
[% IF c("var/windows-x86_64") -%]
export CC=/var/tmp/dist/mingw-w64/bin/x86_64-w64-mingw32-gcc
export CXX=/var/tmp/dist/mingw-w64/bin/x86_64-w64-mingw32-g++
[% END -%]

CMAKE_FLAGS="-DCMAKE_BUILD_TYPE=MinSizeRel
                -DFORCE_QT5=ON
                -DProtobuf_USE_STATIC_LIBS=ON
                -DProtobuf_ROOT_DIR=/var/tmp/dist/protobuf
                -DProtobuf_PROTOC_EXECUTABLE=/var/tmp/dist/protoc/bin/protoc
                -DOPENSSL_USE_STATIC_LIBS=ON
                -DOPENSSL_ROOT_DIR=/var/tmp/dist/openssl/openssl
                -DUSE_SUBMODULE_FMT=ON
                -DSTATIC_QT_ROOT_DIR=/var/tmp/dist/qt
                -DSTATIC_QT=ON
                -DTEGO_STATIC_BUILD=ON"

# Set toolchain file
[% IF c("var/linux-i686") -%]
    CMAKE_FLAGS="-DCMAKE_TOOLCHAIN_FILE=../src/cmake/toolchains/i386-linux-gnu.cmake $CMAKE_FLAGS"
[% END -%]
[% IF c("var/windows-i686") -%]
    CMAKE_FLAGS="-DCMAKE_TOOLCHAIN_FILE=../src/cmake/toolchains/i386-w64-mingw32.cmake $CMAKE_FLAGS"
[% END -%]
[% IF c("var/windows-x86_64") -%]
    CMAKE_FLAGS="-DCMAKE_TOOLCHAIN_FILE=../src/cmake/toolchains/x86_64-w64-mingw32.cmake $CMAKE_FLAGS"
[% END -%]
[% IF c("var/osx") -%]
    # Set AR and RANLIB on macos
    CMAKE_FLAGS="-DCMAKE_AR=$OSX_AR -DCMAKE_RANLIB=$OSX_RANLIB $CMAKE_FLAGS"

    # CMake doesn't honour the CMAKE_AR and CMAKE_RANLIB vars when checking for
    # IPO, see https://github.com/emscripten-core/emscripten/issues/11143.
    # Workaround this by CMAKE_(C|CXX)_COMPILER_(AR|RANLIB)
    CMAKE_FLAGS="-DCMAKE_C_COMPILER_AR=$OSX_AR -DCMAKE_CXX_COMPILER_AR=$OSX_AR $CMAKE_FLAGS"
    CMAKE_FLAGS="-DCMAKE_C_COMPILER_RANLIB=$OSX_RANLIB -DCMAKE_CXX_COMPILER_RANLIB=$OSX_RANLIB $CMAKE_FLAGS"

    # Setting CXX in macosx-toolchain breaks protoc's build, as it ends up
    # creating an unusable binary. Instead, macosx-toolchain set's it in
    # OSX_CXX, so as to not conflict with protoc
    export CXX=$OSX_CXX

    CMAKE_FLAGS="-DCMAKE_TOOLCHAIN_FILE=../src/cmake/toolchains/x86_64-apple-darwin.cmake $CMAKE_FLAGS"
[% END -%]

mkdir build && cd build
RICOCHET_REFRESH_VERSION=[% c('var/tego_version') %] cmake -S ../src $CMAKE_FLAGS

cmake --build . -j[% c("buildconf/num_procs") %]

mkdir /var/tmp/dist/tego/
cp -a /var/tmp/build/[% project %]-[% c('version') %]/build/ricochet-refresh/ricochet-refresh/* /var/tmp/dist/tego/
cd /var/tmp/dist
[% c('tar', {
        tar_src => [ project ],
        tar_args => '-czf ' _ dest_dir _ '/' _ c('filename'),
    }) %]
